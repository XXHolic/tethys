# JavaScript

## 基本类型

### String

### Number

#### NaN

1. 数值中只有 0 除以 0 会返回NaN

2. 任何涉及 NaN 的操作（例如NaN/10）都会返回NaN

3. NaN 与任何值都不相等，包括NaN 本身

4. isNaN() 方法，注意空字符串会返回 false，跟测试数字返回值一样

#### 类型转换

1. Numbert(null) 返回值是 0

2. Numbert(undefined) 返回值是 NaN

### Boolean

### Object

### Undefined

1. null === undefined 为 true，因为，undefined 值是派生自null 值的。



### Null

1. 发音 [nʌl]

2. typeof null 返回的值是 object

### Symbol

1. symbol 类型的是独一无二的，可以来来防止属性名相同的冲突

2. symbol 不能使用 new Symbol()

3. Boolean() 转换为 true

参考链接：http://es6.ruanyifeng.com/#docs/symbol

## 作用域和内存

### 作用域

- 作用域是一套规则，用于确定在何处以及如何查找变量

### 垃圾回收

#### 标记清除

- 垃圾收集器会给存储在内存中的所有变量都加上标记，它会去掉正在使用或被引用变量的标记。每隔一段时间就会“清理”那些带有标记的变量。

#### 引用计数

- 跟踪记录每个值被引用的次数。当引用次数为 0 的就会被回收。

- 这种方式有个严重的问题：相互引用。这样就永远回收不了。

### 内存泄漏

- 使用的内存，一直没有得到释放，比较常见的就是变量的引用一直存在。

- 相应的还有一个 “内存溢出” 概念：程序向系统申请一定大小的内存，而系统不能满足程序要求，于是产生了溢出。

## 对象

### 原型链

1. 原型链中的原型指的是 `Prototype` 属性。

2. JavaScript 中的对象都有一个内置的 Prototype ，其实就是对象的引用。

3. 当访问对象中的属性不存在时，就会查找对象内部 Prototype 关联的对象，这个关联关系就形成了一条原型链。Prototype 链最终都会指向内置的 Object.prototype 。

4. 很常见的例子，就是模仿类，也就是常说的构造函数，用构造函数声明的对象，都是通过原型链相互关联起来，看起来像类一样，但其实有这本质的区别：**类是可以复制多次，就像模具一样，但   JavaScript 并没有类似的复制机制**

### 闭包

1. 闭包其实在 JavaScript 中很常见，它是基于作用域写代码产生的结果。

2. 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。

**作用**

实现模块，模块主要有2个特征：

1.  为创建内部作用域而调用了一个包装函数

2. 包装函数的返回值必须至少包括一个对内部函数的引用

### this

## 事件

### 冒泡

### 捕获

### 模拟事件

### 事件管理

## 请求

### ajax 

### promise

### fetch

## 跨域
