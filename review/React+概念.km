{"root":{"data":{"id":"58c927d2d36d","created":1562481893,"text":"React 概念"},"children":[{"data":{"id":"bvctn641w5c0","created":1562482001255,"text":"元素渲染","note":"- 元素描述了你在屏幕上想看到的内容。\n\n- 元素是构成 React 应用的最小砖块。"},"children":[]},{"data":{"id":"bvcuivz930o0","created":1562484486850,"text":"组件","note":"- 从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。\n\n"},"children":[{"data":{"id":"bvculvkc78g0","created":1562484721041,"text":"class","note":"- class 组件\n\n```javascript\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```"},"children":[]},{"data":{"id":"bvculy2qom80","created":1562484726507,"text":"function","note":"- 纯函数组件\n\n```javascript\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```"},"children":[]}]},{"data":{"id":"bvcuj9bjg3k0","created":1562484515892,"text":"Props","note":"- 当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为 “props”。"},"children":[{"data":{"id":"bvculr6kcrk0","created":1562484711501,"text":"只读","note":"- 组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props。\n"},"children":[]},{"data":{"id":"bvcumunbs340","created":1562484797409,"text":"纯函数","note":"- 所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。"},"children":[]}]},{"data":{"id":"bvcuy42vcuw0","created":1562485679946,"text":"state","note":"- 不要直接修改 State\n\n- 代表了随时间会产生变化的数据，应当仅在实现交互时使用"},"children":[{"data":{"id":"bvcuzlf0f1c0","created":1562485796050,"text":"异步"},"children":[]},{"data":{"id":"bvcuzn5gn2w0","created":1562485799826,"text":"合并"},"children":[]}]},{"data":{"id":"bvcv034xi940","created":1562485834622,"text":"事件处理","note":"React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同:\n\n- React 事件的命名采用小驼峰式（camelCase），而不是纯小写\n- 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。\n\n在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault\n\ne 是一个合成事件。React 根据 W3C 规范来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。"},"children":[{"data":{"id":"bvcv3idn05k0","created":1562486102893,"text":"小驼峰式"},"children":[]},{"data":{"id":"bvcv3qoepzc0","created":1562486120958,"text":"传入函数"},"children":[]}]},{"data":{"id":"bvcvb9coe740","created":1562486710157,"text":"表单","note":"- 在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同"},"children":[{"data":{"id":"bvcvbls46bc0","created":1562486737212,"text":"textarea","note":"- 在 HTML 中, <textarea> 元素通过其子元素定义其文本\n```html\n  <textarea>\n  你好， 这是在 text area 里的文本\n</textarea>\n```\n  \n  \n  \n- 在 React 中，<textarea> 使用 value 属性代替。"},"children":[]},{"data":{"id":"bvcvdcqoldc0","created":1562486874262,"text":"select","note":"- 在 HTML 中，<select> 创建下拉列表标签，selected 属性表示选中\n  \n  \n- React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。"},"children":[]},{"data":{"id":"bvcvhdhatls0","created":1562487189329,"text":"受控组件","note":"- 使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。\n\n- 推荐使用"},"children":[]},{"data":{"id":"bvcvhfw1i9s0","created":1562487194574,"text":"非受控组件","note":"- 表单数据将交由 DOM 节点来处理。\n\n-  使用 ref 来从 DOM 节点中获取表单数据。\n\n- 这类通常适用于简单表单，只需要在提交时校验"},"children":[]}]},{"data":{"id":"bvcw1jvfrzc0","created":1562488770527,"text":"状态提升","note":"- 在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state"},"children":[]},{"data":{"id":"bvcwafbmm2g0","created":1562489465900,"text":"React 哲学"},"children":[{"data":{"id":"bvcwaj2m3p40","created":1562489474062,"text":"数据 state","note":"通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：\n\n1. 该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。\n2. 该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。\n3. 你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。"},"children":[]},{"data":{"id":"bvcwblcwaug0","created":1562489557402,"text":"组件 state","note":"哪个组件能够改变这些 state，或者说拥有这些 state。\n\n对于应用中的每一个 state：\n\n- 找到根据这个 state 进行渲染的所有组件。\n\n- 找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。\n\n- 该共同所有者组件或者比它层级更高的组件应该拥有该 state。\n\n- 如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。"},"children":[]}]}]},"template":"right","theme":"fresh-blue","version":"1.4.43"}