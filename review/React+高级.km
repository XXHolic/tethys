{"root":{"data":{"id":"7fd65125e574","created":1562489860,"text":"React 高级"},"children":[{"data":{"id":"bvcwourxot40","created":1562490596636,"text":"无障碍辅助功能"},"children":[{"data":{"id":"bvcwp9v2b4o0","created":1562490629477,"text":"aria-*"},"children":[]},{"data":{"id":"bvcwpg9ul7c0","created":1562490643432,"text":"语义化标签","note":"- 无意义的 div 可以使用组件 React.Fragment 或短语法代替\n\nReact.Fragment\n```javascript\nclass Columns extends React.Component {\n  render() {\n    return (\n      <React.Fragment>\n        <td>Hello</td>\n        <td>World</td>\n      </React.Fragment>\n    );\n  }\n}\n```\n\n短语法\n```javascript\nclass Columns extends React.Component {\n  render() {\n    return (\n      <>\n        <td>Hello</td>\n        <td>World</td>\n      </>\n    );\n  }\n}\n```\n"},"children":[]},{"data":{"id":"bvcwq8cp1140","created":1562490704554,"text":"表单"},"children":[]},{"data":{"id":"bvcwq9feljc0","created":1562490706894,"text":"焦点"},"children":[]},{"data":{"id":"bvcwqmteihs0","created":1562490736039,"text":"语言"},"children":[]},{"data":{"id":"bvcwqo89j0g0","created":1562490739114,"text":"色彩对比度"},"children":[]}]},{"data":{"id":"bvcwv3h248g0","created":1562491085754,"text":"Context","note":"- Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。"},"children":[{"data":{"id":"bvcx39bfukw0","created":1562491725389,"text":"场景","note":"- 地区偏好，UI 主题"},"children":[]},{"data":{"id":"bvcx3ap0fuw0","created":1562491728386,"text":"思考","note":"- 如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个比 context 更好的解决方案。"},"children":[]}]},{"data":{"id":"bvcx9d34wk00","created":1562492203779,"text":"错误边界","note":null},"children":[{"data":{"id":"bvcxa40hf7c0","created":1562492262391,"text":"React 16","note":"- 自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。\n\n- 在开发环境下，React 16 会把渲染期间发生的所有错误打印到控制台，即使该应用意外的将这些错误掩盖。除了错误信息和 JavaScript 栈外，React 16 还提供了组件栈追踪。"},"children":[]},{"data":{"id":"bvcxb5962ao0","created":1562492343457,"text":"定义","note":"- 是一种 React 组件\n\n- 可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。\n\n- 错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。\n"},"children":[]},{"data":{"id":"bvcxbl7nznk0","created":1562492378195,"text":"场景","note":"错误边界无法捕获以下场景中产生的错误：\n\n- 事件处理（了解更多）\n- 异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）\n- 服务端渲染\n- 它自身抛出来的错误（并非它的子组件）"},"children":[]}]},{"data":{"id":"bvcxnzdbfz40","created":1562493349382,"text":"Refs 转发"},"children":[{"data":{"id":"bvcxohy6qds0","created":1562493389826,"text":"定义","note":"- Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧\n\n- React.forwardRef \n\n- React.createRef()，React 16.3 引入\n\n```javascript\nconst FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"FancyButton\">\n    {props.children}\n  </button>\n));\n\n// 你可以直接获取 DOM button 的 ref：\nconst ref = React.createRef();\n<FancyButton ref={ref}>Click me!</FancyButton>;\n```"},"children":[]},{"data":{"id":"bvcxopoff1s0","created":1562493406650,"text":"场景","note":"- 对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。"},"children":[]},{"data":{"id":"bvcxpf6zqu80","created":1562493462192,"text":"注意","note":"- 当你开始在组件库中使用 forwardRef 时，你应当将其视为一个破坏性更改，并发布库的一个新的主版本。"},"children":[]}]},{"data":{"id":"bvcxspxg40w0","created":1562493720652,"text":"Fragments","note":"- Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。\n\n```javascript\nrender() {\n  return (\n    <React.Fragment>\n      <ChildA />\n      <ChildB />\n      <ChildC />\n    </React.Fragment>\n  );\n}\n```"},"children":[]},{"data":{"id":"bvd2ts3808g0","created":1562507909268,"text":"高阶组件","note":"- 高阶组件是参数为组件，返回值为新组件的函数"},"children":[{"data":{"id":"bvd35iyz6q80","created":1562508829791,"text":"特性","note":"- HOC 不会修改传入的组件，也不会使用继承来复制其行为\n\n- HOC 是纯函数，没有副作用。"},"children":[]},{"data":{"id":"bvd35kjhys00","created":1562508833208,"text":"注意","note":"- 不要试图在 HOC 中修改组件原型（或以其他方式改变它）\n\n- HOC 应该透传与自身无关的 props。\n\n- 不要在 render 方法中使用 HOC\n\n- 务必复制静态方法\n\n- Refs 不会被传递"},"children":[]}]},{"data":{"id":"bvd3b13l11s0","created":1562509261072,"text":"Portals"},"children":[{"data":{"id":"bvd3bzedwww0","created":1562509335736,"text":"作用","note":"- Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。"},"children":[]},{"data":{"id":"bvd3qo1im600","created":1562510486476,"text":"特点","note":"- 一个从 portal 内部触发的事件会一直冒泡至包含 React 树的祖先，即便这些元素并不是 DOM 树 中的祖先"},"children":[]}]},{"data":{"id":"bvd3sci13nk0","created":1562510618081,"text":"Diff 算法","note":"React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法：\n\n- 两个不同类型的元素会产生出不同的树；\n\n- 开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定；\n\n\nDiff 算法：\n1. React 首先比较两棵树的根节点。\n   1.1 当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。\n\n2. 比对同一类型的元素，React 会保留 DOM 节点，仅比对及更新有改变的属性。\n\n\n在处理完当前节点之后，React 继续对子节点进行递归。\n\n对子节点进行递归：\n- 当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。但这种方式会带来低效问题，为此使用了 key 属性，通过 key 的比较进行相关操作，有移动、增加、删除。"},"children":[]},{"data":{"id":"bvf6qe6ncyo0","created":1562722048261,"text":"Refs and the DOM","note":"- Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。"},"children":[{"data":{"id":"bvf6qmz3gd40","created":1562722067395,"text":"场景","note":"- 管理焦点，文本选择或媒体播放。\n- 触发强制动画。\n- 集成第三方 DOM 库。"},"children":[]},{"data":{"id":"bvf7hspzdgg0","created":1562724195738,"text":"ref ","note":"ref 的值根据节点的类型而有所不同：\n\n1. 当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。\n\n2. 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。\n\n3. 你不能在函数组件上使用 ref 属性，因为他们没有实例。"},"children":[]}]},{"data":{"id":"bvf7j5432y00","created":1562724301076,"text":"Render Props"},"children":[{"data":{"id":"bvf7jefyhhs0","created":1562724321385,"text":"定义","note":"- 术语 “render prop” 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术\n\n- 更具体地说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。\n"},"children":[]},{"data":{"id":"bvf7vp9ehfs0","created":1562725285303,"text":"注意","note":"将 Render Props 与 React.PureComponent 一起使用时要小心\n\n- 如果你在 render 方法里创建函数，那么使用 render prop 会抵消使用 React.PureComponent 带来的优势。因为浅比较 props 的时候总会得到 false，并且在这种情况下每一个 render 对于 render prop 将会生成一个新的值。"},"children":[]}]},{"data":{"id":"bvgwzkt8rrs0","created":1562897676780,"text":"严格模式"},"children":[{"data":{"id":"bvgxglsltf40","created":1562899011109,"text":"作用","note":"- StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。"},"children":[]},{"data":{"id":"bvgxgxbo6y00","created":1562899036206,"text":"好处","note":"- 识别不安全的生命周期\n- 关于使用过时字符串 ref API 的警告\n- 关于使用废弃的 findDOMNode 方法的警告\n- 检测意外的副作用\n-检测过时的 context API"},"children":[]}]}]},"template":"right","theme":"fresh-blue","version":"1.4.43"}