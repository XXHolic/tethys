{"root":{"data":{"id":"5f4eed2c1a17","created":1560849620,"text":"Redux","note":"- https://www.redux.org.cn/"},"children":[{"data":{"id":"buwr1kacat40","created":1560849706573,"text":"动机","layout_right_offset":{"x":-7,"y":-246},"note":"- 让状态可控，可预测，方便管理\n\n- 跟随 Flux、CQRS 和 Event Sourcing 的脚步，通过限制更新发生的时间和方式，Redux 试图让 state 的变化变得可预测。"},"children":[]},{"data":{"id":"buwvp20glts0","created":1560862831972,"text":"三大原则","layout_right_offset":{"x":3,"y":93}},"children":[{"data":{"id":"buwvp4xxgnc0","created":1560862838350,"text":"单一数据源","note":"- 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。"},"children":[]},{"data":{"id":"buwvpa3f6cg0","created":1560862849566,"text":"State 是只读的","note":"- 唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。"},"children":[]},{"data":{"id":"buwvpzv4yww0","created":1560862905661,"text":"使用纯函数来执行修改","note":"- Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state"},"children":[]}]},{"data":{"id":"buwvyvyrxu00","created":1560863602451,"text":"概念","layout_right_offset":{"x":-11,"y":-333}},"children":[{"data":{"id":"buwvzpg0y5s0","created":1560863666621,"text":"Action","note":"- 是把数据从应传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。\n\n- Action 创建函数就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。\n"},"children":[]},{"data":{"id":"buww3qk44fk0","created":1560863982502,"text":"Reducers","note":"- 指定了应用状态的变化如何响应 actions 并发送到 store \n\n- 在没有得到 state 副本前，不要修改 state\n\n永远不要在 reducer 里做这些操作：\n- 修改传入参数；\n- 执行有副作用的操作，如 API 请求和路由跳转；\n- 调用非纯函数，如 Date.now() 或 Math.random()。"},"children":[]},{"data":{"id":"buwwc5fb44w0","created":1560864641776,"text":"Store","note":"- 把它们Action和 Reducers联系到一起的对象。\n-  Redux 应用只有一个单一的 store。\n\n\nStore 有以下职责：\n- 维持应用的 state；\n- 提供 getState() 方法获取 state；\n- 提供 dispatch(action) 方法更新 state；\n- 通过 subscribe(listener) 注册监听器;\n- 通过 subscribe(listener) 返回的函数注销监听器。"},"children":[]}]}]},"template":"right","theme":"fresh-blue","version":"1.4.43"}