{"root":{"data":{"id":"7ec19e7d5091","created":1563067969,"text":"Vue"},"children":[{"data":{"id":"bvjnxp8to6g0","created":1563176819582,"text":"定义","note":"- 是一套用于构建用户界面的渐进式框架。"},"children":[]},{"data":{"id":"bvjnxqfw6qo0","created":1563176822186,"text":"特性"},"children":[{"data":{"id":"bvjo3t8lrlk0","created":1563177298460,"text":"指令","note":"- 指令带有前缀 v-，以表示它们是 Vue 提供的特殊特性。"},"children":[{"data":{"id":"bvjo4krogh40","created":1563177358387,"text":"v-bind ","note":"```js\n<div id=\"app-2\">\n  <span v-bind:title=\"message\">\n    鼠标悬停几秒钟查看此处动态绑定的提示信息！\n  </span>\n</div>\n\nvar app2 = new Vue({\n  el: '#app-2',\n  data: {\n    message: '页面加载于 ' + new Date().toLocaleString()\n  }\n})\n```\n此处该指令的意思是：“将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致”。"},"children":[]},{"data":{"id":"bvjo50vb9mo0","created":1563177393435,"text":"v-if","note":"```js\n<div id=\"app-3\">\n  <p v-if=\"seen\">现在你看到我了</p>\n</div>\n\nvar app3 = new Vue({\n  el: '#app-3',\n  data: {\n    seen: true\n  }\n})\n```"},"children":[]},{"data":{"id":"bvjo6rgyemw0","created":1563177529704,"text":"v-for","note":"```js\n<div id=\"app-4\">\n  <ol>\n    <li v-for=\"todo in todos\">\n      {{ todo.text }}\n    </li>\n  </ol>\n</div>\n\n\nvar app4 = new Vue({\n  el: '#app-4',\n  data: {\n    todos: [\n      { text: '学习 JavaScript' },\n      { text: '学习 Vue' },\n      { text: '整个牛项目' }\n    ]\n  }\n})\n```"},"children":[]},{"data":{"id":"bvjo7fb62r40","created":1563177581597,"text":"v-on","note":"```js\n<div id=\"app-5\">\n  <p>{{ message }}</p>\n  <button v-on:click=\"reverseMessage\">反转消息</button>\n</div>\n\n\nvar app5 = new Vue({\n  el: '#app-5',\n  data: {\n    message: 'Hello Vue.js!'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})\n```"},"children":[]},{"data":{"id":"bvjo889p36g0","created":1563177644635,"text":"v-model","note":"- 实现表单输入和应用状态之间的双向绑定。\n\n```js\n<div id=\"app-6\">\n  <p>{{ message }}</p>\n  <input v-model=\"message\">\n</div>\n\nvar app6 = new Vue({\n  el: '#app-6',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n```"},"children":[]}]},{"data":{"id":"bvjo969h0q80","created":1563177718632,"text":"组件"},"children":[{"data":{"id":"bvjp7vc3k540","created":1563180437592,"text":"全局注册","note":"- 用在任何新创建的 Vue 根实例 (new Vue) 的模板中\n```js\nVue.component('my-component-name', {\n  // ... 选项 ...\n})\n```"},"children":[]},{"data":{"id":"bvjp7x8w6jk0","created":1563180441752,"text":"局部注册"},"children":[]}]}]},{"data":{"id":"bvjnztmrysg0","created":1563176985861,"text":"生命周期","note":"- https://cn.vuejs.org/images/lifecycle.png\n\n- 在beforeCreate和created钩子函数之间进行初始化，beforeCreate的时候还没有 data \n\n- created 和 beforeMount 间的，首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译。如果有就会按照下面的有限顺序执行：render函数选项 > template选项 > outer HTML.\n\n- beforeMount 和 mounted 之间，给vue实例对象添加$el成员，并且替换掉挂在的DOM元素 "},"children":[{"data":{"id":"bvjodninccg0","created":1563178069649,"text":"beforeCreate"},"children":[]},{"data":{"id":"bvjodx5pgww0","created":1563178090634,"text":"created"},"children":[]},{"data":{"id":"bvjoe80j6sg0","created":1563178114266,"text":"beforeMount"},"children":[]},{"data":{"id":"bvjoeend0kw0","created":1563178128707,"text":"mounted"},"children":[]},{"data":{"id":"bvjoepbdu7c0","created":1563178151927,"text":"beforeUpdate"},"children":[]},{"data":{"id":"bvjoex66vj40","created":1563178169027,"text":"updated"},"children":[]},{"data":{"id":"bvjof3ctus00","created":1563178182489,"text":"beforeDestroy"},"children":[]},{"data":{"id":"bvjofglgfy80","created":1563178211309,"text":"destroyed"},"children":[]}]},{"data":{"id":"bvjo23i7hl40","created":1563177164081,"text":"响应式原理","note":"- new Vue() 时传递的 data 属性是一个对象，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。\n\n- 每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。https://cn.vuejs.org/images/data.png\n\n- Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n\n- 由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明所有根级响应式属性，哪怕只是一个空值\n\n- Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。"},"children":[]}]},"template":"right","theme":"fresh-blue","version":"1.4.43"}